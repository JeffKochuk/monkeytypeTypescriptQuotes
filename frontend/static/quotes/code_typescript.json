{
  "language": "code_typescript",
  "groups": [
    [0, 100],
    [101, 300],
    [301, 600],
    [601, 9999]
  ],
  "quotes": [
    {
      "text": "export class TreeNode<T> {\n  value?: T;\n  parent?: TreeNode<T>;\n  children: TreeNode<T>[];\n\n  constructor(value?: T, opts?: { parent?: TreeNode<T>, children?: TreeNode<T>[] }) {\n    this.value = value;\n    this.parent = opts?.parent;\n    this.children = opts?.children ? [...opts.children] : [];\n  }\n\n  add(value: T, opts?: { index?: number }): TreeNode<T> {\n    const child = new TreeNode<T>(value, { parent: this });\n    const idx = Math.min(Math.max(opts?.index ?? this.children.length, 0), this.children.length);\n    this.children.splice(idx, 0, child);\n    return child;\n  }\n}",
      "source": "typescript-algorithms",
      "id": 1,
      "length": 581
    },
    {
      "text": "export function binarySearch(nums: number[], target: number): number {\n  let low = 0, high = nums.length - 1;\n  while (low <= high) {\n    const mid = (low + high) >> 1;\n    const value = nums[mid];\n    if (value === target) return mid;\n    if (value < target) low = mid + 1; else high = mid - 1;\n  }\n  return -1; // not found\n}",
      "source": "typescript-algorithms",
      "id": 2,
      "length": 327
    },
    {
      "text": "export function quickSort(a: number[], lo = 0, hi = a.length - 1): void {\n  if (lo >= hi) return; // base case\n  const p = partition(a, lo, hi);\n  quickSort(a, lo, p - 1);\n  quickSort(a, p + 1, hi);\n}\nfunction partition(a: number[], lo: number, hi: number): number {\n  const pivot = a[hi];\n  let i = lo;\n  for (let j = lo; j < hi; j++) {\n    if (a[j] <= pivot) { [a[i], a[j]] = [a[j], a[i]]; i++; }\n  }\n  [a[i], a[hi]] = [a[hi], a[i]];\n  return i;\n}",
      "source": "typescript-algorithms",
      "id": 3,
      "length": 449
    },
    {
      "text": "export function mergeSort(a: number[]): number[] {\n  if (a.length <= 1) return a;\n  const mid = a.length >> 1;\n  const left = mergeSort(a.slice(0, mid));\n  const right = mergeSort(a.slice(mid));\n  return merge(left, right);\n}\nfunction merge(l: number[], r: number[]): number[] {\n  const out: number[] = [];\n  let i = 0, j = 0;\n  while (i < l.length && j < r.length) {\n    if (l[i] <= r[j]) out.push(l[i++]); else out.push(r[j++]);\n  }\n  return out.concat(l.slice(i)).concat(r.slice(j));\n}",
      "source": "typescript-algorithms",
      "id": 4,
      "length": 488
    },
    {
      "text": "export function dijkstra(graph: Record<string, [string, number][]>, start: string) {\n  const dist: Record<string, number> = {};\n  const seen = new Set<string>();\n  Object.keys(graph).forEach(v => dist[v] = v === start ? 0 : Infinity);\n  const pq: [number, string][] = [[0, start]]; // [distance, node]\n  while (pq.length) {\n    pq.sort((a, b) => a[0] - b[0]); // simple PQ for clarity\n    const [d, u] = pq.shift()!;\n    if (seen.has(u)) continue;\n    seen.add(u);\n    for (const [v, w] of graph[u] || []) {\n      const nd = d + w;\n      if (nd < dist[v]) { dist[v] = nd; pq.push([nd, v]); }\n    }\n  }\n  return dist;\n}",
      "source": "typescript-algorithms",
      "id": 5,
      "length": 618
    },
    {
      "text": "export function bfs(adj: Record<string, string[]>, s: string): Record<string, number> {\n  const dist: Record<string, number> = { [s]: 0 };\n  const q: string[] = [s];\n  let head = 0;\n  while (head < q.length) {\n    const u = q[head++];\n    for (const v of adj[u] || []) {\n      if (dist[v] === undefined) {\n        dist[v] = dist[u] + 1; // tree edge\n        q.push(v);\n      }\n    }\n  }\n  return dist;\n}",
      "source": "typescript-algorithms",
      "id": 6,
      "length": 403
    },
    {
      "text": "export function dfs(adj: Record<string, string[]>, s: string): string[] {\n  const order: string[] = [];\n  const seen = new Set<string>();\n  function visit(u: string) {\n    seen.add(u);\n    for (const v of adj[u] || []) if (!seen.has(v)) visit(v);\n    order.push(u); // postorder\n  }\n  visit(s);\n  return order;\n}",
      "source": "typescript-algorithms",
      "id": 7,
      "length": 312
    },
    {
      "text": "export function topoSort(adj: Record<string, string[]>): string[] {\n  const indeg: Record<string, number> = {};\n  for (const u in adj) { indeg[u] ??= 0; for (const v of adj[u]) indeg[v] = (indeg[v] || 0) + 1; }\n  const q: string[] = Object.keys(indeg).filter(k => indeg[k] === 0);\n  const order: string[] = [];\n  let head = 0;\n  while (head < q.length) {\n    const u = q[head++];\n    order.push(u);\n    for (const v of adj[u] || []) {\n      if (--indeg[v] === 0) q.push(v);\n    }\n  }\n  return order; // if order.length < n, a cycle exists\n}",
      "source": "typescript-algorithms",
      "id": 8,
      "length": 540
    },
    {
      "text": "export function kadane(a: number[]): number {\n  let best = -Infinity;\n  let cur = 0;\n  for (const x of a) {\n    cur = Math.max(x, cur + x);\n    best = Math.max(best, cur);\n  }\n  return best;\n}",
      "source": "typescript-algorithms",
      "id": 9,
      "length": 192
    },
    {
      "text": "export class UnionFind {\n  private parent: number[];\n  private rank: number[];\n  constructor(n: number) {\n    this.parent = Array.from({length: n}, (_, i) => i);\n    this.rank = Array(n).fill(0);\n  }\n  find(x: number): number {\n    return this.parent[x] === x ? x : (this.parent[x] = this.find(this.parent[x]));\n  }\n  union(a: number, b: number): boolean {\n    let ra = this.find(a), rb = this.find(b);\n    if (ra === rb) return false;\n    if (this.rank[ra] < this.rank[rb]) [ra, rb] = [rb, ra];\n    this.parent[rb] = ra;\n    if (this.rank[ra] === this.rank[rb]) this.rank[ra]++;\n    return true;\n  }\n}",
      "source": "typescript-algorithms",
      "id": 10,
      "length": 602
    },
    {
      "text": "export function fib(n: number): number {\n  if (n <= 1) return n;\n  let a = 0, b = 1;\n  for (let i = 2; i <= n; i++) {\n    const c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;\n}",
      "source": "typescript-algorithms",
      "id": 11,
      "length": 178
    },
    {
      "text": "export function heapSort(a: number[]): number[] {\n  const n = a.length;\n  for (let i = (n >> 1) - 1; i >= 0; i--) heapify(a, n, i); // build max-heap\n  for (let end = n - 1; end > 0; end--) {\n    [a[0], a[end]] = [a[end], a[0]]; // move max to end\n    heapify(a, end, 0); // restore heap\n  }\n  return a;\n}\nfunction heapify(a: number[], n: number, i: number): void {\n  let largest = i;\n  const l = 2 * i + 1, r = 2 * i + 2;\n  if (l < n && a[l] > a[largest]) largest = l;\n  if (r < n && a[r] > a[largest]) largest = r;\n  if (largest !== i) { [a[i], a[largest]] = [a[largest], a[i]]; heapify(a, n, largest); }\n}",
      "source": "typescript-algorithms",
      "id": 12,
      "length": 608
    },
    {
      "text": "export function countingSort(a: number[], maxVal: number): number[] {\n  const count = new Array(maxVal + 1).fill(0);\n  for (const x of a) count[x]++; // count occurrences\n  for (let i = 1; i < count.length; i++) count[i] += count[i - 1]; // prefix sums\n  const out = new Array(a.length);\n  for (let i = a.length - 1; i >= 0; i--) {\n    const x = a[i];\n    out[--count[x]] = x; // stable placement\n  }\n  return out;\n}",
      "source": "typescript-algorithms",
      "id": 13,
      "length": 416
    },
    {
      "text": "export function prim(adj: Record<string, [string, number][]>, start: string) {\n  const inMST = new Set<string>();\n  const parent: Record<string, string | null> = {};\n  const key: Record<string, number> = {};\n  for (const u in adj) { key[u] = Infinity; parent[u] = null; }\n  key[start] = 0;\n  const pq: [number, string, string | null][] = [[0, start, null]]; // [key, node, parent]\n  while (pq.length) {\n    pq.sort((a, b) => a[0] - b[0]);\n    const [k, u, p] = pq.shift()!;\n    if (inMST.has(u)) continue;\n    inMST.add(u); parent[u] = p;\n    for (const [v, w] of adj[u] || []) {\n      if (!inMST.has(v) && w < key[v]) { key[v] = w; pq.push([w, v, u]); }\n    }\n  }\n  return { parent, key };\n}",
      "source": "typescript-algorithms",
      "id": 14,
      "length": 692
    },
    {
      "text": "export function kruskal(n: number, edges: [number, number, number][]) {\n  edges.sort((a, b) => a[2] - b[2]);\n  const uf = new UF(n);\n  const mst: [number, number, number][] = [];\n  for (const [u, v, w] of edges) {\n    if (uf.union(u, v)) mst.push([u, v, w]); // add edge if it connects two sets\n    if (mst.length === n - 1) break;\n  }\n  return mst;\n}\nclass UF {\n  parent: number[];\n  rank: number[];\n  constructor(n: number) {\n    this.parent = Array.from({ length: n }, (_, i) => i);\n    this.rank = Array(n).fill(0);\n  }\n  find(x: number): number {\n    return this.parent[x] === x ? x : (this.parent[x] = this.find(this.parent[x]));\n  }\n  union(a: number, b: number): boolean {\n    let ra = this.find(a), rb = this.find(b);\n    if (ra === rb) return false;\n    if (this.rank[ra] < this.rank[rb]) [ra, rb] = [rb, ra];\n    this.parent[rb] = ra;\n    if (this.rank[ra] === this.rank[rb]) this.rank[ra]++;\n    return true;\n  }\n}",
      "source": "typescript-algorithms",
      "id": 15,
      "length": 926
    },
    {
      "text": "export function bellmanFord(n: number, edges: [number,number,number][], src: number) {\n  const dist = Array(n).fill(Infinity);\n  dist[src] = 0;\n  for (let i = 0; i < n - 1; i++) {\n    let updated = false;\n    for (const [u,v,w] of edges) {\n      if (dist[u] + w < dist[v]) { dist[v] = dist[u] + w; updated = true; }\n    }\n    if (!updated) break; // early stop if no changes\n  }\n  for (const [u,v,w] of edges) {\n    if (dist[u] + w < dist[v]) throw new Error('negative cycle');\n  }\n  return dist;\n}",
      "source": "typescript-algorithms",
      "id": 16,
      "length": 498
    },
    {
      "text": "export function floydWarshall(dist: number[][]): number[][] {\n  const n = dist.length;\n  const d = dist.map(row => row.slice()); // copy\n  for (let k = 0; k < n; k++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        const nd = d[i][k] + d[k][j];\n        if (nd < d[i][j]) d[i][j] = nd;\n      }\n    }\n  }\n  return d;\n}",
      "source": "typescript-algorithms",
      "id": 17,
      "length": 348
    },
    {
      "text": "export function kmpSearch(text: string, pattern: string): number[] {\n  if (!pattern) return [];\n  const lps = buildLPS(pattern);\n  const res: number[] = [];\n  let i = 0, j = 0; // i over text, j over pattern\n  while (i < text.length) {\n    if (text[i] === pattern[j]) { i++; j++; if (j === pattern.length) { res.push(i - j); j = lps[j-1]; } }\n    else if (j > 0) j = lps[j-1]; else i++;\n  }\n  return res;\n}\nfunction buildLPS(p: string): number[] {\n  const lps = Array(p.length).fill(0);\n  let len = 0;\n  for (let i = 1; i < p.length; ) {\n    if (p[i] === p[len]) lps[i++] = ++len;\n    else if (len) len = lps[len-1];\n    else lps[i++] = 0;\n  }\n  return lps;\n}",
      "source": "typescript-algorithms",
      "id": 18,
      "length": 659
    },
    {
      "text": "export function rabinKarp(text: string, pattern: string): number[] {\n  const n = text.length, m = pattern.length;\n  if (!m) return [];\n  const base = 911382323, mod = 972663749; // large primes\n  let hp = 0, ht = 0, pow = 1;\n  for (let i = 0; i < m; i++) {\n    hp = (hp * base + pattern.charCodeAt(i)) % mod;\n    ht = (ht * base + text.charCodeAt(i)) % mod;\n    if (i < m - 1) pow = (pow * base) % mod;\n  }\n  const res: number[] = [];\n  for (let i = 0; i <= n - m; i++) {\n    if (hp === ht && text.slice(i, i + m) === pattern) res.push(i);\n    if (i < n - m) {\n      ht = ( (ht - text.charCodeAt(i) * pow % mod + mod) % mod );\n      ht = (ht * base + text.charCodeAt(i + m)) % mod;\n    }\n  }\n  return res;\n}",
      "source": "typescript-algorithms",
      "id": 19,
      "length": 707
    },
    {
      "text": "export function quickSelect(a: number[], k: number, lo = 0, hi = a.length - 1): number {\n  while (lo <= hi) {\n    const p = partition(a, lo, hi); // pivot index\n    if (p === k) return a[p];\n    if (p < k) lo = p + 1; else hi = p - 1;\n  }\n  return NaN;\n}\nfunction partition(a: number[], lo: number, hi: number): number {\n  const pivot = a[hi];\n  let i = lo;\n  for (let j = lo; j < hi; j++) {\n    if (a[j] <= pivot) { [a[i], a[j]] = [a[j], a[i]]; i++; }\n  }\n  [a[i], a[hi]] = [a[hi], a[i]];\n  return i;\n}",
      "source": "typescript-algorithms",
      "id": 20,
      "length": 503
    },
    {
      "text": "export class Fenwick {\n  private bit: number[];\n  constructor(size: number) { this.bit = new Array(size + 1).fill(0); }\n  add(index: number, delta: number): void {\n    for (let i = index + 1; i < this.bit.length; i += i & -i) this.bit[i] += delta;\n  }\n  sum(index: number): number { // prefix sum [0..index]\n    let res = 0;\n    for (let i = index + 1; i > 0; i -= i & -i) res += this.bit[i];\n    return res;\n  }\n  rangeSum(l: number, r: number): number { // inclusive\n    return this.sum(r) - (l ? this.sum(l - 1) : 0);\n  }\n}",
      "source": "typescript-algorithms",
      "id": 21,
      "length": 526
    }
  ]
}
